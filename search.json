[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "O que é que APRENDI HOJE?",
    "section": "",
    "text": "Publicando Pacotes no PyPI\n\n\nNeste artigo você aprenderá como criar um pacote e publicar no pypi.org\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEstruturas de Dados em Python\n\n\nNeste artigo você aprenderá quais as estruturas de dados mais comuns em python\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/python-basics/python_estruturas_dados_tutorial.html",
    "href": "posts/python-basics/python_estruturas_dados_tutorial.html",
    "title": "Estruturas de Dados em Python",
    "section": "",
    "text": "Este notebook apresenta, de forma prática e objetiva, as principais estruturas de dados do Python: listas, tuplas, conjuntos (sets) e dicionários. Também veremos compreensões, cópias (rasas e profundas), e como usar pilhas/filas com list e collections.deque.\n\nRecomendado para iniciantes e como revisão rápida.\n\n\n\n\nPré-requisitos e dicas\nTipos básicos (contexto rápido)\nListas (list)\nTuplas (tuple)\nConjuntos (set, frozenset)\nDicionários (dict)\nCompreensões (list/set/dict)\nCópias: rasa vs profunda\nPilhas e Filas\nExercícios práticos\n\n\n\n\n\nTer o Python 3 instalado e noções básicas de variáveis e funções.\nUse print() e experimente: modifique os exemplos!\nDocumentação oficial: https://docs.python.org/3/tutorial/\n\n\n\n\nPython tem vários tipos embutidos. Alguns úteis como contexto para as estruturas de dados:\n\nint, float, bool\nstr (strings são imutáveis)\nNone (ausência de valor)\nbytes, bytearray (úteis para dados binários)\n\n\nAs estruturas de dados que veremos a seguir armazenam esses valores.\n\n\n\n\n\nMutáveis\nOrdenadas (mantêm a ordem de inserção)\nPermitem elementos repetidos\nAcessadas por índice (começa em 0)\n\n\n# Criação e acesso\nnums = [10, 20, 30, 40]\nprint(\"lista:\", nums)\nprint(\"primeiro elemento:\", nums[0])\nprint(\"último elemento:\", nums[-1])\n\n# Slicing (fatiamento)\nprint(\"slice 1..3:\", nums[1:3])\nprint(\"cópia rasa via slice:\", nums[:])  # nova lista com os mesmos itens\n\nlista: [10, 20, 30, 40]\nprimeiro elemento: 10\núltimo elemento: 40\nslice 1..3: [20, 30]\ncópia rasa via slice: [10, 20, 30, 40]\n\n\n\n# Métodos comuns\nnums = [3, 1, 4]\nnums.append(1)        # adiciona no fim\nnums.extend([5, 9])   # estende com iterável\nnums.insert(1, 2)     # insere na posição 1\nprint(nums)\n\nnums.remove(1)        # remove primeira ocorrência de 1\nprint(nums)\n\npopped = nums.pop()   # remove e retorna o último\nprint(\"popped:\", popped, \"| lista:\", nums)\n\nnums.reverse()        # in-place\nprint(\"reversa:\", nums)\n\n# sort in-place vs sorted (cópia ordenada)\nnums.sort()\nprint(\"sort:\", nums)\nprint(\"sorted (cópia):\", sorted([3,1,4,1,5]))\n\n[3, 2, 1, 4, 1, 5, 9]\n[3, 2, 4, 1, 5, 9]\npopped: 9 | lista: [3, 2, 4, 1, 5]\nreversa: [5, 1, 4, 2, 3]\nsort: [1, 2, 3, 4, 5]\nsorted (cópia): [1, 1, 3, 4, 5]\n\n\n\n# Comportamento de mutabilidade\na = [1, 2, 3]\nb = a           # b referencia a MESMA lista\nb.append(4)\nprint(\"a:\", a, \"| b:\", b)  # ambos mudam\n\n# Se quiser uma cópia rasa:\nc = a.copy()\nc.append(5)\nprint(\"a (após copy):\", a, \"| c:\", c)\n\na: [1, 2, 3, 4] | b: [1, 2, 3, 4]\na (após copy): [1, 2, 3, 4] | c: [1, 2, 3, 4, 5]\n\n\n\n# Listas aninhadas e armadilhas de cópia rasa\nimport copy\n\nm1 = [[1,2],[3,4]]\nm2 = m1.copy()           # cópia rasa: sublistas são compartilhadas\nm2[0].append(99)\nprint(\"m1:\", m1, \"| m2:\", m2)  # ambas afetadas\n\nm3 = copy.deepcopy(m1)   # cópia profunda: estrutura completa duplicada\nm3[1].append(77)\nprint(\"m1:\", m1, \"| m3:\", m3)\n\nm1: [[1, 2, 99], [3, 4]] | m2: [[1, 2, 99], [3, 4]]\nm1: [[1, 2, 99], [3, 4]] | m3: [[1, 2, 99], [3, 4, 77]]\n\n\n\n\n\n\nImutáveis\nOrdenadas\nÚteis para agrupamento de dados e como chaves de dicionários (quando composto por itens imutáveis)\n\nDica: desembrulhar (unpacking) é muito prático com tuplas.\n\n# Criação e unpacking\nponto = (3, 4)\nx, y = ponto\nprint(f\"x={x}, y={y}\")\n\n# Tupla de 1 elemento precisa de vírgula final\num = (42,)\nprint(type(um), um)\n\nx=3, y=4\n&lt;class 'tuple'&gt; (42,)\n\n\n\n\n\n\nNão ordenados (sem índices)\nÚnicos (eliminam duplicatas)\nOperações de teoria de conjuntos: união, interseção, diferença\n\nfrozenset é a versão imutável de set.\n\nA = {1, 2, 3, 3}\nB = set([3, 4, 5])\n\nprint(\"A (sem duplicatas):\", A)\nprint(\"B:\", B)\nprint(\"união:\", A | B)\nprint(\"interseção:\", A & B)\nprint(\"diferença A-B:\", A - B)\nprint(\"diferença simétrica:\", A ^ B)\n\n# frozenset\nF = frozenset([1,2,2,3])\nprint(\"frozenset:\", F)\n\nA (sem duplicatas): {1, 2, 3}\nB: {3, 4, 5}\nunião: {1, 2, 3, 4, 5}\ninterseção: {3}\ndiferença A-B: {1, 2}\ndiferença simétrica: {1, 2, 4, 5}\nfrozenset: frozenset({1, 2, 3})\n\n\n\n\n\n\nMutáveis\nMapeiam chaves para valores\nDesde o Python 3.7 preservam a ordem de inserção\n\nChaves precisam ser hashable (imutáveis, como str, int, tuple de imutáveis, frozenset).\n\n# Criação e acesso\nprecos = {\"banana\": 5.0, \"maçã\": 4.5}\nprint(\"preços:\", precos)\nprint(\"preço da maçã:\", precos[\"maçã\"])\n\n# get com default (evita KeyError)\nprint(\"preço da pera (default -1):\", precos.get(\"pera\", -1))\n\n# Inserção/atualização\nprecos[\"laranja\"] = 6.0\nprecos.update({\"banana\": 5.5})\nprint(precos)\n\n# Remoção\nval = precos.pop(\"laranja\")\nprint(\"removido:\", val, \"| atual:\", precos)\n\n# Iteração\nfor fruta, valor in precos.items():\n    print(fruta, \"-&gt;\", valor)\n\npreços: {'banana': 5.0, 'maçã': 4.5}\npreço da maçã: 4.5\npreço da pera (default -1): -1\n{'banana': 5.5, 'maçã': 4.5, 'laranja': 6.0}\nremovido: 6.0 | atual: {'banana': 5.5, 'maçã': 4.5}\nbanana -&gt; 5.5\nmaçã -&gt; 4.5\n\n\n\n# Métodos úteis\nd = {\"a\": 1, \"b\": 2}\nprint(\"keys:\", list(d.keys()))\nprint(\"values:\", list(d.values()))\nprint(\"items:\", list(d.items()))\n\n# setdefault: retorna valor existente ou define default\ncontagens = {}\nfor ch in \"banana\":\n    contagens.setdefault(ch, 0)\n    contagens[ch] += 1\nprint(\"contagens:\", contagens)\n\nkeys: ['a', 'b']\nvalues: [1, 2]\nitems: [('a', 1), ('b', 2)]\ncontagens: {'b': 1, 'a': 3, 'n': 2}\n\n\n\n\n\nForma concisa e pythonista de construir coleções.\n\n# List comprehension\nquadrados = [x*x for x in range(6)]\nprint(\"quadrados:\", quadrados)\n\n# Com condição (if)\npares = [x for x in range(10) if x % 2 == 0]\nprint(\"pares:\", pares)\n\n# Dict comprehension\nd = {x: x*x for x in range(5)}\nprint(\"dict:\", d)\n\n# Set comprehension\ns = {ch for ch in \"abracadabra\" if ch not in \"bc\"}\nprint(\"set:\", s)\n\nquadrados: [0, 1, 4, 9, 16, 25]\npares: [0, 2, 4, 6, 8]\ndict: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}\nset: {'r', 'a', 'd'}\n\n\n\n\n\n\nCópia rasa (shallow): duplica apenas o contêiner, compartilha referências internas.\n\nExemplos: list.copy(), dict.copy(), set.copy(), slicing (seq[:]), copy.copy(obj)\n\nCópia profunda (deep): duplica recursivamente toda a estrutura.\n\nExemplo: copy.deepcopy(obj)\n\n\n\nimport copy\n\noriginal = {\"nums\": [1,2,3], \"ok\": True}\nshallow = original.copy()\ndeep = copy.deepcopy(original)\n\nshallow[\"nums\"].append(99)\ndeep[\"nums\"].append(77)\n\nprint(\"original:\", original)\nprint(\"shallow :\", shallow)\nprint(\"deep    :\", deep)\n\noriginal: {'nums': [1, 2, 3, 99], 'ok': True}\nshallow : {'nums': [1, 2, 3, 99], 'ok': True}\ndeep    : {'nums': [1, 2, 3, 77], 'ok': True}\n\n\n\n\n\n\nPilha (stack): LIFO. Use list com append() / pop().\nFila (queue): FIFO. Prefira collections.deque (eficiente em ambos os lados).\n\n\n# Pilha com list\nstack = []\nstack.append(\"a\")\nstack.append(\"b\")\nprint(\"pop:\", stack.pop())  # remove \"b\"\nprint(\"resto:\", stack)\n\npop: b\nresto: ['a']\n\n\n\n# Fila com deque\nfrom collections import deque\n\nfila = deque()\nfila.append(\"primeiro\")\nfila.append(\"segundo\")\nprint(\"popleft:\", fila.popleft())  # remove \"primeiro\"\nprint(\"resto:\", fila)\n\npopleft: primeiro\nresto: deque(['segundo'])\n\n\n\n\n\nExecute as células e complete onde indicado. Há asserts para conferir automaticamente.\n\n# 10.1) Remova duplicatas preservando a ordem usando set de apoio\ndef remove_duplicatas(seq):\n    vistos = set()\n    res = []\n    for x in seq:\n        if x not in vistos:\n            vistos.add(x)\n            res.append(x)\n    return res\n\nassert remove_duplicatas([1,2,1,3,2,1,4]) == [1,2,3,4]\nprint(\"OK 10.1\")\n\nOK 10.1\n\n\n\n# 10.2) Construa um dicionário de contagem de caracteres (case-insensitive) para uma string s\ndef contagem_chars(s):\n    s = s.lower()\n    cont = {}\n    for ch in s:\n        if ch.isalpha():\n            cont[ch] = cont.get(ch, 0) + 1\n    return cont\n\nassert contagem_chars(\"Banana!\") == {\"b\":1, \"a\":3, \"n\":2}\nprint(\"OK 10.2\")\n\nOK 10.2\n\n\n\n# 10.3) Use comprehension para obter os quadrados dos pares de 0..20\nquadrados_pares = [x*x for x in range(21) if x % 2 == 0]\nassert quadrados_pares[:5] == [0, 4, 16, 36, 64]\nprint(\"OK 10.3\")\n\nOK 10.3\n\n\n\n# 10.4) Extra: converter uma lista de pares (chave, valor) em dict e inverter (valor-&gt;chave)\npares = [(\"a\",1), (\"b\",2), (\"c\",3)]\nd = dict(pares)\ninvertido = {v:k for k,v in d.items()}\nassert d[\"b\"] == 2 and invertido[3] == \"c\"\nprint(\"OK 10.4 — gerado em 2025-08-09 22:49:32\")\n\nOK 10.4 — gerado em 2025-08-09 22:49:32\n\n\n\n\n\nDocumentação oficial: Built-in Types e Data Structures no tutorial do Python.\ncollections (e.g., Counter, defaultdict, namedtuple), heapq, array, bisect.\nPratique escrevendo funções que consomem e produzem essas estruturas."
  },
  {
    "objectID": "posts/python-basics/python_estruturas_dados_tutorial.html#sumário",
    "href": "posts/python-basics/python_estruturas_dados_tutorial.html#sumário",
    "title": "Estruturas de Dados em Python",
    "section": "",
    "text": "Pré-requisitos e dicas\nTipos básicos (contexto rápido)\nListas (list)\nTuplas (tuple)\nConjuntos (set, frozenset)\nDicionários (dict)\nCompreensões (list/set/dict)\nCópias: rasa vs profunda\nPilhas e Filas\nExercícios práticos"
  },
  {
    "objectID": "posts/python-basics/python_estruturas_dados_tutorial.html#pré-requisitos-e-dicas",
    "href": "posts/python-basics/python_estruturas_dados_tutorial.html#pré-requisitos-e-dicas",
    "title": "Estruturas de Dados em Python",
    "section": "",
    "text": "Ter o Python 3 instalado e noções básicas de variáveis e funções.\nUse print() e experimente: modifique os exemplos!\nDocumentação oficial: https://docs.python.org/3/tutorial/"
  },
  {
    "objectID": "posts/python-basics/python_estruturas_dados_tutorial.html#tipos-básicos-contexto-rápido",
    "href": "posts/python-basics/python_estruturas_dados_tutorial.html#tipos-básicos-contexto-rápido",
    "title": "Estruturas de Dados em Python",
    "section": "",
    "text": "Python tem vários tipos embutidos. Alguns úteis como contexto para as estruturas de dados:\n\nint, float, bool\nstr (strings são imutáveis)\nNone (ausência de valor)\nbytes, bytearray (úteis para dados binários)\n\n\nAs estruturas de dados que veremos a seguir armazenam esses valores."
  },
  {
    "objectID": "posts/python-basics/python_estruturas_dados_tutorial.html#listas-list",
    "href": "posts/python-basics/python_estruturas_dados_tutorial.html#listas-list",
    "title": "Estruturas de Dados em Python",
    "section": "",
    "text": "Mutáveis\nOrdenadas (mantêm a ordem de inserção)\nPermitem elementos repetidos\nAcessadas por índice (começa em 0)\n\n\n# Criação e acesso\nnums = [10, 20, 30, 40]\nprint(\"lista:\", nums)\nprint(\"primeiro elemento:\", nums[0])\nprint(\"último elemento:\", nums[-1])\n\n# Slicing (fatiamento)\nprint(\"slice 1..3:\", nums[1:3])\nprint(\"cópia rasa via slice:\", nums[:])  # nova lista com os mesmos itens\n\nlista: [10, 20, 30, 40]\nprimeiro elemento: 10\núltimo elemento: 40\nslice 1..3: [20, 30]\ncópia rasa via slice: [10, 20, 30, 40]\n\n\n\n# Métodos comuns\nnums = [3, 1, 4]\nnums.append(1)        # adiciona no fim\nnums.extend([5, 9])   # estende com iterável\nnums.insert(1, 2)     # insere na posição 1\nprint(nums)\n\nnums.remove(1)        # remove primeira ocorrência de 1\nprint(nums)\n\npopped = nums.pop()   # remove e retorna o último\nprint(\"popped:\", popped, \"| lista:\", nums)\n\nnums.reverse()        # in-place\nprint(\"reversa:\", nums)\n\n# sort in-place vs sorted (cópia ordenada)\nnums.sort()\nprint(\"sort:\", nums)\nprint(\"sorted (cópia):\", sorted([3,1,4,1,5]))\n\n[3, 2, 1, 4, 1, 5, 9]\n[3, 2, 4, 1, 5, 9]\npopped: 9 | lista: [3, 2, 4, 1, 5]\nreversa: [5, 1, 4, 2, 3]\nsort: [1, 2, 3, 4, 5]\nsorted (cópia): [1, 1, 3, 4, 5]\n\n\n\n# Comportamento de mutabilidade\na = [1, 2, 3]\nb = a           # b referencia a MESMA lista\nb.append(4)\nprint(\"a:\", a, \"| b:\", b)  # ambos mudam\n\n# Se quiser uma cópia rasa:\nc = a.copy()\nc.append(5)\nprint(\"a (após copy):\", a, \"| c:\", c)\n\na: [1, 2, 3, 4] | b: [1, 2, 3, 4]\na (após copy): [1, 2, 3, 4] | c: [1, 2, 3, 4, 5]\n\n\n\n# Listas aninhadas e armadilhas de cópia rasa\nimport copy\n\nm1 = [[1,2],[3,4]]\nm2 = m1.copy()           # cópia rasa: sublistas são compartilhadas\nm2[0].append(99)\nprint(\"m1:\", m1, \"| m2:\", m2)  # ambas afetadas\n\nm3 = copy.deepcopy(m1)   # cópia profunda: estrutura completa duplicada\nm3[1].append(77)\nprint(\"m1:\", m1, \"| m3:\", m3)\n\nm1: [[1, 2, 99], [3, 4]] | m2: [[1, 2, 99], [3, 4]]\nm1: [[1, 2, 99], [3, 4]] | m3: [[1, 2, 99], [3, 4, 77]]"
  },
  {
    "objectID": "posts/python-basics/python_estruturas_dados_tutorial.html#tuplas-tuple",
    "href": "posts/python-basics/python_estruturas_dados_tutorial.html#tuplas-tuple",
    "title": "Estruturas de Dados em Python",
    "section": "",
    "text": "Imutáveis\nOrdenadas\nÚteis para agrupamento de dados e como chaves de dicionários (quando composto por itens imutáveis)\n\nDica: desembrulhar (unpacking) é muito prático com tuplas.\n\n# Criação e unpacking\nponto = (3, 4)\nx, y = ponto\nprint(f\"x={x}, y={y}\")\n\n# Tupla de 1 elemento precisa de vírgula final\num = (42,)\nprint(type(um), um)\n\nx=3, y=4\n&lt;class 'tuple'&gt; (42,)"
  },
  {
    "objectID": "posts/python-basics/python_estruturas_dados_tutorial.html#conjuntos-set-frozenset",
    "href": "posts/python-basics/python_estruturas_dados_tutorial.html#conjuntos-set-frozenset",
    "title": "Estruturas de Dados em Python",
    "section": "",
    "text": "Não ordenados (sem índices)\nÚnicos (eliminam duplicatas)\nOperações de teoria de conjuntos: união, interseção, diferença\n\nfrozenset é a versão imutável de set.\n\nA = {1, 2, 3, 3}\nB = set([3, 4, 5])\n\nprint(\"A (sem duplicatas):\", A)\nprint(\"B:\", B)\nprint(\"união:\", A | B)\nprint(\"interseção:\", A & B)\nprint(\"diferença A-B:\", A - B)\nprint(\"diferença simétrica:\", A ^ B)\n\n# frozenset\nF = frozenset([1,2,2,3])\nprint(\"frozenset:\", F)\n\nA (sem duplicatas): {1, 2, 3}\nB: {3, 4, 5}\nunião: {1, 2, 3, 4, 5}\ninterseção: {3}\ndiferença A-B: {1, 2}\ndiferença simétrica: {1, 2, 4, 5}\nfrozenset: frozenset({1, 2, 3})"
  },
  {
    "objectID": "posts/python-basics/python_estruturas_dados_tutorial.html#dicionários-dict",
    "href": "posts/python-basics/python_estruturas_dados_tutorial.html#dicionários-dict",
    "title": "Estruturas de Dados em Python",
    "section": "",
    "text": "Mutáveis\nMapeiam chaves para valores\nDesde o Python 3.7 preservam a ordem de inserção\n\nChaves precisam ser hashable (imutáveis, como str, int, tuple de imutáveis, frozenset).\n\n# Criação e acesso\nprecos = {\"banana\": 5.0, \"maçã\": 4.5}\nprint(\"preços:\", precos)\nprint(\"preço da maçã:\", precos[\"maçã\"])\n\n# get com default (evita KeyError)\nprint(\"preço da pera (default -1):\", precos.get(\"pera\", -1))\n\n# Inserção/atualização\nprecos[\"laranja\"] = 6.0\nprecos.update({\"banana\": 5.5})\nprint(precos)\n\n# Remoção\nval = precos.pop(\"laranja\")\nprint(\"removido:\", val, \"| atual:\", precos)\n\n# Iteração\nfor fruta, valor in precos.items():\n    print(fruta, \"-&gt;\", valor)\n\npreços: {'banana': 5.0, 'maçã': 4.5}\npreço da maçã: 4.5\npreço da pera (default -1): -1\n{'banana': 5.5, 'maçã': 4.5, 'laranja': 6.0}\nremovido: 6.0 | atual: {'banana': 5.5, 'maçã': 4.5}\nbanana -&gt; 5.5\nmaçã -&gt; 4.5\n\n\n\n# Métodos úteis\nd = {\"a\": 1, \"b\": 2}\nprint(\"keys:\", list(d.keys()))\nprint(\"values:\", list(d.values()))\nprint(\"items:\", list(d.items()))\n\n# setdefault: retorna valor existente ou define default\ncontagens = {}\nfor ch in \"banana\":\n    contagens.setdefault(ch, 0)\n    contagens[ch] += 1\nprint(\"contagens:\", contagens)\n\nkeys: ['a', 'b']\nvalues: [1, 2]\nitems: [('a', 1), ('b', 2)]\ncontagens: {'b': 1, 'a': 3, 'n': 2}"
  },
  {
    "objectID": "posts/python-basics/python_estruturas_dados_tutorial.html#compreensões-listsetdict",
    "href": "posts/python-basics/python_estruturas_dados_tutorial.html#compreensões-listsetdict",
    "title": "Estruturas de Dados em Python",
    "section": "",
    "text": "Forma concisa e pythonista de construir coleções.\n\n# List comprehension\nquadrados = [x*x for x in range(6)]\nprint(\"quadrados:\", quadrados)\n\n# Com condição (if)\npares = [x for x in range(10) if x % 2 == 0]\nprint(\"pares:\", pares)\n\n# Dict comprehension\nd = {x: x*x for x in range(5)}\nprint(\"dict:\", d)\n\n# Set comprehension\ns = {ch for ch in \"abracadabra\" if ch not in \"bc\"}\nprint(\"set:\", s)\n\nquadrados: [0, 1, 4, 9, 16, 25]\npares: [0, 2, 4, 6, 8]\ndict: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}\nset: {'r', 'a', 'd'}"
  },
  {
    "objectID": "posts/python-basics/python_estruturas_dados_tutorial.html#cópias-shallow-vs-deep",
    "href": "posts/python-basics/python_estruturas_dados_tutorial.html#cópias-shallow-vs-deep",
    "title": "Estruturas de Dados em Python",
    "section": "",
    "text": "Cópia rasa (shallow): duplica apenas o contêiner, compartilha referências internas.\n\nExemplos: list.copy(), dict.copy(), set.copy(), slicing (seq[:]), copy.copy(obj)\n\nCópia profunda (deep): duplica recursivamente toda a estrutura.\n\nExemplo: copy.deepcopy(obj)\n\n\n\nimport copy\n\noriginal = {\"nums\": [1,2,3], \"ok\": True}\nshallow = original.copy()\ndeep = copy.deepcopy(original)\n\nshallow[\"nums\"].append(99)\ndeep[\"nums\"].append(77)\n\nprint(\"original:\", original)\nprint(\"shallow :\", shallow)\nprint(\"deep    :\", deep)\n\noriginal: {'nums': [1, 2, 3, 99], 'ok': True}\nshallow : {'nums': [1, 2, 3, 99], 'ok': True}\ndeep    : {'nums': [1, 2, 3, 77], 'ok': True}"
  },
  {
    "objectID": "posts/python-basics/python_estruturas_dados_tutorial.html#pilhas-e-filas",
    "href": "posts/python-basics/python_estruturas_dados_tutorial.html#pilhas-e-filas",
    "title": "Estruturas de Dados em Python",
    "section": "",
    "text": "Pilha (stack): LIFO. Use list com append() / pop().\nFila (queue): FIFO. Prefira collections.deque (eficiente em ambos os lados).\n\n\n# Pilha com list\nstack = []\nstack.append(\"a\")\nstack.append(\"b\")\nprint(\"pop:\", stack.pop())  # remove \"b\"\nprint(\"resto:\", stack)\n\npop: b\nresto: ['a']\n\n\n\n# Fila com deque\nfrom collections import deque\n\nfila = deque()\nfila.append(\"primeiro\")\nfila.append(\"segundo\")\nprint(\"popleft:\", fila.popleft())  # remove \"primeiro\"\nprint(\"resto:\", fila)\n\npopleft: primeiro\nresto: deque(['segundo'])"
  },
  {
    "objectID": "posts/python-basics/python_estruturas_dados_tutorial.html#exercícios-práticos",
    "href": "posts/python-basics/python_estruturas_dados_tutorial.html#exercícios-práticos",
    "title": "Estruturas de Dados em Python",
    "section": "",
    "text": "Execute as células e complete onde indicado. Há asserts para conferir automaticamente.\n\n# 10.1) Remova duplicatas preservando a ordem usando set de apoio\ndef remove_duplicatas(seq):\n    vistos = set()\n    res = []\n    for x in seq:\n        if x not in vistos:\n            vistos.add(x)\n            res.append(x)\n    return res\n\nassert remove_duplicatas([1,2,1,3,2,1,4]) == [1,2,3,4]\nprint(\"OK 10.1\")\n\nOK 10.1\n\n\n\n# 10.2) Construa um dicionário de contagem de caracteres (case-insensitive) para uma string s\ndef contagem_chars(s):\n    s = s.lower()\n    cont = {}\n    for ch in s:\n        if ch.isalpha():\n            cont[ch] = cont.get(ch, 0) + 1\n    return cont\n\nassert contagem_chars(\"Banana!\") == {\"b\":1, \"a\":3, \"n\":2}\nprint(\"OK 10.2\")\n\nOK 10.2\n\n\n\n# 10.3) Use comprehension para obter os quadrados dos pares de 0..20\nquadrados_pares = [x*x for x in range(21) if x % 2 == 0]\nassert quadrados_pares[:5] == [0, 4, 16, 36, 64]\nprint(\"OK 10.3\")\n\nOK 10.3\n\n\n\n# 10.4) Extra: converter uma lista de pares (chave, valor) em dict e inverter (valor-&gt;chave)\npares = [(\"a\",1), (\"b\",2), (\"c\",3)]\nd = dict(pares)\ninvertido = {v:k for k,v in d.items()}\nassert d[\"b\"] == 2 and invertido[3] == \"c\"\nprint(\"OK 10.4 — gerado em 2025-08-09 22:49:32\")\n\nOK 10.4 — gerado em 2025-08-09 22:49:32\n\n\n\n\n\nDocumentação oficial: Built-in Types e Data Structures no tutorial do Python.\ncollections (e.g., Counter, defaultdict, namedtuple), heapq, array, bisect.\nPratique escrevendo funções que consomem e produzem essas estruturas."
  },
  {
    "objectID": "posts/python-basics/publicando_pacotes_no_pypi.html",
    "href": "posts/python-basics/publicando_pacotes_no_pypi.html",
    "title": "Publicando Pacotes no PyPI",
    "section": "",
    "text": "Neste tutorial você aprenderá como criar um projeto usando uv, instalar dependências, construir testes com mock e publicar como um pacote no pypi.org.\n\n\n\nConfigurando o ambiente\nCriando um projeto\nInstalar dependências\nCriar o código\nTestes com pytest\nPublicando PyPI\nReferências\n\n\n\n\n\n\nPara instalar o uv no seu sistema siga as instruções da documentação do uv para seu sistema.\nPor exemplo, para usuários linux, podemos instalar o uv da seguinte forma:\ncurl -LsSf https://astral.sh/uv/install.sh | sh\nPodemos verificar a instalação do uv, com o comando\nuv --version\nSaída:\n# uv 0.8.5\n\n\n\nCom o uv instalado você pode instalar qualquer versão do python que desejar, por exemplo, para instalar o python 3.13 rode o comando\nuv python install 3.13\nVocê pode instalar diversas versões do python no seu sistema, para tornar padrão uma versão específica, no uv, utilize o comando abaixo\nuv python install 3.13 --default\n\n\n\nPara este tutorial utilizaremos o vscode com o plugins:\n\nPython: ms-python.python\nPylance: ms-python.vscode-pylance\nPython Environments: ms-python.vscode-python-envs\n\n\n\n\n\nPara criar um projeto, no nosso caso, um projeto de lib de python utilizamos o comando init do uv\nuv init --lib duden-webscraper\nApós criar o projeto abra com o vscode\ncode duden-webscraper\nvocê verá a segunte estrutura de arquivos\n.\n├── src\n│   └── duden_webscraper\n│       ├── __init__.py\n│       └── py.typed\n├── README.md\n└── pyproject.toml\numa breve decrição de cada arquivo:\n\n./src/duden_webscraper/__init__.py: O arquivo __init__.py é uma maneira de indicar ao Python que o diretório no qual ele se encontra deve ser tratado como um pacote (ou módulo).\n./src/duden_webscraper/py.typed: Utilizado por analisadores estáticos como o mypy para determinar se o código do módulo está de acordo com as anotações de tipo especificadas, ajudando a encontrar erros de tipo em tempo de desenvolvimento. É geralmente um arquivo vazio, mas sua presença no diretório do módulo indica a compatibilidade com anotações de tipo.\nREADME.md: É um arquivo markdown geralmente utilizado para documentação do pacote.\npyproject.toml: arquivo de configuração utilizado por ferramentas como o uv para declarar configurações do projeto. No caso do uv por exemplo, conterá informações sobre depedências, metadados do projeto como nome e descrição, versão do pacote e do python entre outras coisas.\n\n\n\n\nO nosso projeto consiste de um webscraper que coleta informações do website duden.de a respeito de uma determinada palavra buscada. A ação implementada pode ser vista no diagrama abaixo\nsequenceDiagram\n    actor User\n    participant Website as duden.de\n\n    User-&gt;&gt;Website: GET /rechtschreibung/{word}\n    Website--&gt;&gt;User: metadata (e.g., lemma, POS, Fig, variants)\nPara implementar a funcionalidade precisaremos dos pacotes:\n\nbeautifulsoup4: pacote para manipulação de html.\nrequests: pacote para execução de chamadas http.\n\nPodemos instalar as depedências usando o uv com o comando abaixo:\nuv add beautifulsoup4 requests\nNeste ponto, você verá que ambos os pacotes foram adicionados no arquivo pyproject.toml e o uv criou um arquivo de controle de versionamento chamado uv.lock.\n\n\n\n\n\nO código consiste dos arquivos:\n\nendpoint.py: Contém constantes para a url do website.\n\nclass Endpoint:\n    BASE = \"https://www.duden.de\"\n    DICTIONARY_SEARCH = \"/search_api_autocomplete/dictionary_search\"\n    ORTHOGRAPHY = \"/rechtschreibung\"\n\nduden_web_scraper.py: Contém a lógica de extração de informações do html obtido da consulta.\n\nimport re\nimport requests\nfrom bs4 import BeautifulSoup, Tag, NavigableString\nfrom .endpoint import Endpoint\nfrom .word_info_error import WordInfoError\nfrom .word_not_found_error import WordNotFoundError\n\nclass DudenWebScraper:\n    MIN_ATTEMPTS = 1\n\n    def __init__(self):\n        self.number_attempts = self.MIN_ATTEMPTS\n\n    def get_word_info(self, word: str) -&gt; dict:\n        word = self.__convert(word)\n\n        response = self.__get(Endpoint.ORTHOGRAPHY + \"/\" + word)\n\n        if response is None:\n            raise WordNotFoundError(f\"the word {word} was not found\")\n\n        main = response.find('article')\n        tuples_items = main.find_all(class_='tuple')\n        tuples_items_contents = tuples_items[0].find(class_=\"tuple__val\").text\n\n        frequency = 0\n        word_usage = None\n\n        second_tuple_item = tuples_items[1].find(class_=\"tuple__key\").text\n        is_frequency = second_tuple_item.find(\"Häufigkeit\") == 0\n        frequency_position = 1 if is_frequency else 2\n\n        if frequency_position == 2:\n            word_usage = second_tuple_item.find(class_=\"tuple__val\").text\n\n        frequency_tuples = tuples_items[frequency_position].find(class_=\"tuple__val\").find(class_=\"shaft__full\")\n\n        if len(frequency_tuples) &gt; 0:\n            frequency = frequency_tuples.text\n\n        tuples_contents_pieces = tuples_items_contents.split(\", \")\n        word_gender = None\n\n        if len(tuples_contents_pieces) &gt; 1:\n            word_gender = tuples_contents_pieces[1] if tuples_contents_pieces[1] is not None else None\n\n        lemma = main.find(class_=\"lemma__main\").text.replace(\"\", \"\")\n        determiner = main.find(class_=\"lemma__determiner\")\n        lemma_determiner = determiner.text if len(determiner) &gt; 0 else None\n\n        spelling_items = main.select(\"#rechtschreibung .tuple\")\n        spelling = self.__parse_spelling(spelling_items)\n\n        meaning_items = main.select(\"#bedeutungen ol li\")\n        meaning = self.__parse_meanings(meaning_items)\n\n        return {\n            \"lemma\": lemma,\n            \"lemma_determiner\": lemma_determiner,\n            \"word_type\": tuples_contents_pieces[0],\n            \"word_usage\": word_usage,\n            \"word_gender\": word_gender,\n            \"frequency\": frequency,\n            \"spelling\": spelling,\n            \"meaning\": meaning,\n        }\n\n    def __parse_meaning_kernel_tuples(self, tuples) -&gt; list[dict]:\n        results = []\n\n        for note in tuples:\n            results.append({\n                \"title\": note.find(class_=\"tuple__key\").text,\n                \"items\": [\n                    note.find(class_=\"tuple__val\").text,\n                ],\n            })\n\n        return results\n\n    def __parse_meaning_kernel_notes(self, notes) -&gt; list[dict]:\n        results = []\n\n        for note in notes:\n            items = []\n\n            for item in note.select(\".note__list li\"):\n                items.append(item.text)\n                results.append({\n                    \"title\": note.find(class_=\"note__title\").text,\n                    \"items\": items,\n                })\n\n        return results\n\n    def __parse_meaning_kernel(self, item) -&gt; dict:\n        parsedFigured = None\n        figure = None\n        enumeration_text = None\n        notes = []\n        tuples = []\n\n        if not isinstance(item, NavigableString) and item.select(\"dl.note\"):\n            notes = item.select(\"dl.note\")\n        if not isinstance(item, NavigableString) and item.select(\"dl.tuple\"):\n            tuples = item.select(\"dl.tuple\")\n        if not isinstance(item, NavigableString) and item.find(\"figure\"):\n            figure = item.find(\"figure\")\n        if not isinstance(item, NavigableString) and item.find(class_=\"enumeration__text\"):\n            enumeration_text = item.find(class_=\"enumeration__text\")\n            enumeration_text = enumeration_text.text if len(enumeration_text) &gt; 0 else None\n\n        notes_list = []\n\n        if len(notes) &gt; 1:\n            notes_list = self.__parse_meaning_kernel_notes(notes)\n        else:\n            notes_list = self.__parse_meaning_kernel_tuples(tuples)\n\n        if figure:\n            parsedFigured = {\n                \"link\": figure.find(\"a\")[\"href\"],\n                \"caption\": figure.find(class_=\"depiction__caption\").text,\n            }\n\n        return {\n            \"text\": enumeration_text,\n            \"figure\": parsedFigured,\n            \"notes\": notes_list,\n        }\n\n    def __parse_meanings(self, meanings) -&gt; list:\n        results = []\n\n        for item in meanings:\n            items = []\n            sublists = item.find(class_=\"enumeration__sub-item\")\n\n            if sublists is None:\n                continue\n\n            if len(sublists) &lt; 1:\n                items.append(self.__parse_meaning_kernel(item))\n                continue\n            else:\n                for sublist in sublists:\n                    items.append(self.__parse_meaning_kernel(sublist))\n\n            results.append(items)\n\n        return results\n\n    def __parse_spelling(self, spelling) -&gt; (Tag | NavigableString | None):\n        result = []\n\n        for item in spelling:\n            title = item.find(class_=\"tuple__key\").text\n            value = item.find(class_=\"tuple__val\")\n            result.append({\n                \"title\": title,\n                \"value\": value.text if title != \"Verwandte Form\" else value.find(\"a\").text,\n            })\n\n        return result\n\n    def __get(self, endpoint: str):\n        response = requests.get(Endpoint.BASE + \"/\" + endpoint)\n\n        if response.status_code != 200:\n            raise WordInfoError(\"failed to get word info\")\n\n        soup = BeautifulSoup(response.content, \"html.parser\")\n        return soup.find('body')\n\n    def __convert(self, word: str) -&gt; str:\n        patterns = {\n            '/ä/': 'ae',\n            '/ö/': 'oe',\n            '/ü/': 'ue',\n            '/ß/': 'sz',\n        }\n\n        for pattern, replacement in patterns.items():\n            word = re.sub(pattern, replacement, word)\n\n        return word\n\nword_info_error.py: Utilizado para lançamento de exceção quando o status de retorno da chamada http é diferente de 200.\n\nclass WordInfoError(Exception):\n    pass\n\nword_not_found_error.py: Utilizado para lançamento de exceção caso o retorno da chamada http seja de sucesso mas o website retorne um resultado vazio.\n\nclass WordNotFoundError(Exception):\n    pass\nA estrutura final de diretório é:\n.\n├── src\n│   └── duden_webscraper\n│       ├── __init__.py\n│       ├── duden_web_scraper.py\n│       ├── endpoint.py\n│       ├── py.typed\n│       ├── word_info_error.py\n│       └── word_not_found_error.py\n├── README.md\n├── pyproject.toml\n└── uv.lock\n\n\n\n\nOs arquivos word_info_error.py e word_not_found_error.py são utilizados para especialização de erros. Ao construir pacotes é importante que cada tipo de erro tenha uma modelagem específica para que possa ser tratado de acordo com seu tipo.\nno arquivo duden_web_scraper.py utilizamos métodos iniciando em __ para indicar métodos privados. Como pode ser visto, existe somente um método público (método planejado para uso externo) get_word_info.\n\n\n\n\n\nPara saber se o código que fizemos está funcionado corretamente, poderiamos publicar o pacote no pypi.org e instalar em uma outra aplicação python e usar. No entanto, esta é uma péssima prática.\nA abordagem mais adequada é através de construição de testes unitários, funcionais e de integração:\n\nTestes unitários:\nTestes funcionais:\nTestes de integração:\n\nPara construir os testes vamos utilizar o pacote pytest que pode ser instalado com o uv através do comando\nuv add --dev pytest\nNote que como esta é uma dependência de desenvolvimento uitilizamos a flag --dev.\nPara facilitar a simulação de requests nos testes funcionais também utilizaremos o pacote requests-mock.\nuv add --dev requests-mock\nE finalmente para vermos quando das linhas estão cobertas por testes, utilizaremos a lib de cobertura de tests pytest-cov.\nuv add --dev pytest-cov"
  },
  {
    "objectID": "posts/python-basics/publicando_pacotes_no_pypi.html#sumário",
    "href": "posts/python-basics/publicando_pacotes_no_pypi.html#sumário",
    "title": "Publicando Pacotes no PyPI",
    "section": "",
    "text": "Configurando o ambiente\nCriando um projeto\nInstalar dependências\nCriar o código\nTestes com pytest\nPublicando PyPI\nReferências"
  },
  {
    "objectID": "posts/python-basics/publicando_pacotes_no_pypi.html#configurando-o-ambiente",
    "href": "posts/python-basics/publicando_pacotes_no_pypi.html#configurando-o-ambiente",
    "title": "Publicando Pacotes no PyPI",
    "section": "",
    "text": "Para instalar o uv no seu sistema siga as instruções da documentação do uv para seu sistema.\nPor exemplo, para usuários linux, podemos instalar o uv da seguinte forma:\ncurl -LsSf https://astral.sh/uv/install.sh | sh\nPodemos verificar a instalação do uv, com o comando\nuv --version\nSaída:\n# uv 0.8.5\n\n\n\nCom o uv instalado você pode instalar qualquer versão do python que desejar, por exemplo, para instalar o python 3.13 rode o comando\nuv python install 3.13\nVocê pode instalar diversas versões do python no seu sistema, para tornar padrão uma versão específica, no uv, utilize o comando abaixo\nuv python install 3.13 --default\n\n\n\nPara este tutorial utilizaremos o vscode com o plugins:\n\nPython: ms-python.python\nPylance: ms-python.vscode-pylance\nPython Environments: ms-python.vscode-python-envs"
  },
  {
    "objectID": "posts/python-basics/publicando_pacotes_no_pypi.html#criando-um-projeto",
    "href": "posts/python-basics/publicando_pacotes_no_pypi.html#criando-um-projeto",
    "title": "Publicando Pacotes no PyPI",
    "section": "",
    "text": "Para criar um projeto, no nosso caso, um projeto de lib de python utilizamos o comando init do uv\nuv init --lib duden-webscraper\nApós criar o projeto abra com o vscode\ncode duden-webscraper\nvocê verá a segunte estrutura de arquivos\n.\n├── src\n│   └── duden_webscraper\n│       ├── __init__.py\n│       └── py.typed\n├── README.md\n└── pyproject.toml\numa breve decrição de cada arquivo:\n\n./src/duden_webscraper/__init__.py: O arquivo __init__.py é uma maneira de indicar ao Python que o diretório no qual ele se encontra deve ser tratado como um pacote (ou módulo).\n./src/duden_webscraper/py.typed: Utilizado por analisadores estáticos como o mypy para determinar se o código do módulo está de acordo com as anotações de tipo especificadas, ajudando a encontrar erros de tipo em tempo de desenvolvimento. É geralmente um arquivo vazio, mas sua presença no diretório do módulo indica a compatibilidade com anotações de tipo.\nREADME.md: É um arquivo markdown geralmente utilizado para documentação do pacote.\npyproject.toml: arquivo de configuração utilizado por ferramentas como o uv para declarar configurações do projeto. No caso do uv por exemplo, conterá informações sobre depedências, metadados do projeto como nome e descrição, versão do pacote e do python entre outras coisas."
  },
  {
    "objectID": "posts/python-basics/publicando_pacotes_no_pypi.html#instalando-dependências",
    "href": "posts/python-basics/publicando_pacotes_no_pypi.html#instalando-dependências",
    "title": "Publicando Pacotes no PyPI",
    "section": "",
    "text": "O nosso projeto consiste de um webscraper que coleta informações do website duden.de a respeito de uma determinada palavra buscada. A ação implementada pode ser vista no diagrama abaixo\nsequenceDiagram\n    actor User\n    participant Website as duden.de\n\n    User-&gt;&gt;Website: GET /rechtschreibung/{word}\n    Website--&gt;&gt;User: metadata (e.g., lemma, POS, Fig, variants)\nPara implementar a funcionalidade precisaremos dos pacotes:\n\nbeautifulsoup4: pacote para manipulação de html.\nrequests: pacote para execução de chamadas http.\n\nPodemos instalar as depedências usando o uv com o comando abaixo:\nuv add beautifulsoup4 requests\nNeste ponto, você verá que ambos os pacotes foram adicionados no arquivo pyproject.toml e o uv criou um arquivo de controle de versionamento chamado uv.lock."
  },
  {
    "objectID": "posts/python-basics/publicando_pacotes_no_pypi.html#criando-o-código",
    "href": "posts/python-basics/publicando_pacotes_no_pypi.html#criando-o-código",
    "title": "Publicando Pacotes no PyPI",
    "section": "",
    "text": "O código consiste dos arquivos:\n\nendpoint.py: Contém constantes para a url do website.\n\nclass Endpoint:\n    BASE = \"https://www.duden.de\"\n    DICTIONARY_SEARCH = \"/search_api_autocomplete/dictionary_search\"\n    ORTHOGRAPHY = \"/rechtschreibung\"\n\nduden_web_scraper.py: Contém a lógica de extração de informações do html obtido da consulta.\n\nimport re\nimport requests\nfrom bs4 import BeautifulSoup, Tag, NavigableString\nfrom .endpoint import Endpoint\nfrom .word_info_error import WordInfoError\nfrom .word_not_found_error import WordNotFoundError\n\nclass DudenWebScraper:\n    MIN_ATTEMPTS = 1\n\n    def __init__(self):\n        self.number_attempts = self.MIN_ATTEMPTS\n\n    def get_word_info(self, word: str) -&gt; dict:\n        word = self.__convert(word)\n\n        response = self.__get(Endpoint.ORTHOGRAPHY + \"/\" + word)\n\n        if response is None:\n            raise WordNotFoundError(f\"the word {word} was not found\")\n\n        main = response.find('article')\n        tuples_items = main.find_all(class_='tuple')\n        tuples_items_contents = tuples_items[0].find(class_=\"tuple__val\").text\n\n        frequency = 0\n        word_usage = None\n\n        second_tuple_item = tuples_items[1].find(class_=\"tuple__key\").text\n        is_frequency = second_tuple_item.find(\"Häufigkeit\") == 0\n        frequency_position = 1 if is_frequency else 2\n\n        if frequency_position == 2:\n            word_usage = second_tuple_item.find(class_=\"tuple__val\").text\n\n        frequency_tuples = tuples_items[frequency_position].find(class_=\"tuple__val\").find(class_=\"shaft__full\")\n\n        if len(frequency_tuples) &gt; 0:\n            frequency = frequency_tuples.text\n\n        tuples_contents_pieces = tuples_items_contents.split(\", \")\n        word_gender = None\n\n        if len(tuples_contents_pieces) &gt; 1:\n            word_gender = tuples_contents_pieces[1] if tuples_contents_pieces[1] is not None else None\n\n        lemma = main.find(class_=\"lemma__main\").text.replace(\"\", \"\")\n        determiner = main.find(class_=\"lemma__determiner\")\n        lemma_determiner = determiner.text if len(determiner) &gt; 0 else None\n\n        spelling_items = main.select(\"#rechtschreibung .tuple\")\n        spelling = self.__parse_spelling(spelling_items)\n\n        meaning_items = main.select(\"#bedeutungen ol li\")\n        meaning = self.__parse_meanings(meaning_items)\n\n        return {\n            \"lemma\": lemma,\n            \"lemma_determiner\": lemma_determiner,\n            \"word_type\": tuples_contents_pieces[0],\n            \"word_usage\": word_usage,\n            \"word_gender\": word_gender,\n            \"frequency\": frequency,\n            \"spelling\": spelling,\n            \"meaning\": meaning,\n        }\n\n    def __parse_meaning_kernel_tuples(self, tuples) -&gt; list[dict]:\n        results = []\n\n        for note in tuples:\n            results.append({\n                \"title\": note.find(class_=\"tuple__key\").text,\n                \"items\": [\n                    note.find(class_=\"tuple__val\").text,\n                ],\n            })\n\n        return results\n\n    def __parse_meaning_kernel_notes(self, notes) -&gt; list[dict]:\n        results = []\n\n        for note in notes:\n            items = []\n\n            for item in note.select(\".note__list li\"):\n                items.append(item.text)\n                results.append({\n                    \"title\": note.find(class_=\"note__title\").text,\n                    \"items\": items,\n                })\n\n        return results\n\n    def __parse_meaning_kernel(self, item) -&gt; dict:\n        parsedFigured = None\n        figure = None\n        enumeration_text = None\n        notes = []\n        tuples = []\n\n        if not isinstance(item, NavigableString) and item.select(\"dl.note\"):\n            notes = item.select(\"dl.note\")\n        if not isinstance(item, NavigableString) and item.select(\"dl.tuple\"):\n            tuples = item.select(\"dl.tuple\")\n        if not isinstance(item, NavigableString) and item.find(\"figure\"):\n            figure = item.find(\"figure\")\n        if not isinstance(item, NavigableString) and item.find(class_=\"enumeration__text\"):\n            enumeration_text = item.find(class_=\"enumeration__text\")\n            enumeration_text = enumeration_text.text if len(enumeration_text) &gt; 0 else None\n\n        notes_list = []\n\n        if len(notes) &gt; 1:\n            notes_list = self.__parse_meaning_kernel_notes(notes)\n        else:\n            notes_list = self.__parse_meaning_kernel_tuples(tuples)\n\n        if figure:\n            parsedFigured = {\n                \"link\": figure.find(\"a\")[\"href\"],\n                \"caption\": figure.find(class_=\"depiction__caption\").text,\n            }\n\n        return {\n            \"text\": enumeration_text,\n            \"figure\": parsedFigured,\n            \"notes\": notes_list,\n        }\n\n    def __parse_meanings(self, meanings) -&gt; list:\n        results = []\n\n        for item in meanings:\n            items = []\n            sublists = item.find(class_=\"enumeration__sub-item\")\n\n            if sublists is None:\n                continue\n\n            if len(sublists) &lt; 1:\n                items.append(self.__parse_meaning_kernel(item))\n                continue\n            else:\n                for sublist in sublists:\n                    items.append(self.__parse_meaning_kernel(sublist))\n\n            results.append(items)\n\n        return results\n\n    def __parse_spelling(self, spelling) -&gt; (Tag | NavigableString | None):\n        result = []\n\n        for item in spelling:\n            title = item.find(class_=\"tuple__key\").text\n            value = item.find(class_=\"tuple__val\")\n            result.append({\n                \"title\": title,\n                \"value\": value.text if title != \"Verwandte Form\" else value.find(\"a\").text,\n            })\n\n        return result\n\n    def __get(self, endpoint: str):\n        response = requests.get(Endpoint.BASE + \"/\" + endpoint)\n\n        if response.status_code != 200:\n            raise WordInfoError(\"failed to get word info\")\n\n        soup = BeautifulSoup(response.content, \"html.parser\")\n        return soup.find('body')\n\n    def __convert(self, word: str) -&gt; str:\n        patterns = {\n            '/ä/': 'ae',\n            '/ö/': 'oe',\n            '/ü/': 'ue',\n            '/ß/': 'sz',\n        }\n\n        for pattern, replacement in patterns.items():\n            word = re.sub(pattern, replacement, word)\n\n        return word\n\nword_info_error.py: Utilizado para lançamento de exceção quando o status de retorno da chamada http é diferente de 200.\n\nclass WordInfoError(Exception):\n    pass\n\nword_not_found_error.py: Utilizado para lançamento de exceção caso o retorno da chamada http seja de sucesso mas o website retorne um resultado vazio.\n\nclass WordNotFoundError(Exception):\n    pass\nA estrutura final de diretório é:\n.\n├── src\n│   └── duden_webscraper\n│       ├── __init__.py\n│       ├── duden_web_scraper.py\n│       ├── endpoint.py\n│       ├── py.typed\n│       ├── word_info_error.py\n│       └── word_not_found_error.py\n├── README.md\n├── pyproject.toml\n└── uv.lock\n\n\n\n\nOs arquivos word_info_error.py e word_not_found_error.py são utilizados para especialização de erros. Ao construir pacotes é importante que cada tipo de erro tenha uma modelagem específica para que possa ser tratado de acordo com seu tipo.\nno arquivo duden_web_scraper.py utilizamos métodos iniciando em __ para indicar métodos privados. Como pode ser visto, existe somente um método público (método planejado para uso externo) get_word_info."
  },
  {
    "objectID": "posts/python-basics/publicando_pacotes_no_pypi.html#testes-com-pytest",
    "href": "posts/python-basics/publicando_pacotes_no_pypi.html#testes-com-pytest",
    "title": "Publicando Pacotes no PyPI",
    "section": "",
    "text": "Para saber se o código que fizemos está funcionado corretamente, poderiamos publicar o pacote no pypi.org e instalar em uma outra aplicação python e usar. No entanto, esta é uma péssima prática.\nA abordagem mais adequada é através de construição de testes unitários, funcionais e de integração:\n\nTestes unitários:\nTestes funcionais:\nTestes de integração:\n\nPara construir os testes vamos utilizar o pacote pytest que pode ser instalado com o uv através do comando\nuv add --dev pytest\nNote que como esta é uma dependência de desenvolvimento uitilizamos a flag --dev.\nPara facilitar a simulação de requests nos testes funcionais também utilizaremos o pacote requests-mock.\nuv add --dev requests-mock\nE finalmente para vermos quando das linhas estão cobertas por testes, utilizaremos a lib de cobertura de tests pytest-cov.\nuv add --dev pytest-cov"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  }
]