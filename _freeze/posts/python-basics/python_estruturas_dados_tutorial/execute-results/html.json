{
  "hash": "a703d21216509833fd07d722989bcf50",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Estruturas de Dados em Python\"\ndescription: \"Neste poste você aprenderá quais as estrturas dados mais comuns em python e como utilizá-las\"\nexecute:\n  enabled: true\n---\n\n\n# Tutorial Básico: Estruturas de Dados em Python\n\nEste notebook apresenta, de forma prática e objetiva, as principais estruturas de dados do Python:\n**listas**, **tuplas**, **conjuntos** (*sets*) e **dicionários**. Também veremos **compreensões**, \n**cópias (rasas e profundas)**, e como usar **pilhas/filas** com `list` e `collections.deque`.\n\n> Recomendado para iniciantes e como revisão rápida.\n\n\n## Sumário\n1. [Pré-requisitos e dicas](#pre)\n2. [Tipos básicos (contexto rápido)](#tipos)\n3. [Listas (`list`)](#listas)\n4. [Tuplas (`tuple`)](#tuplas)\n5. [Conjuntos (`set`, `frozenset`)](#sets)\n6. [Dicionários (`dict`)](#dicts)\n7. [Compreensões (list/set/dict)](#comps)\n8. [Cópias: rasa vs profunda](#copias)\n9. [Pilhas e Filas](#pilhasfilas)\n10. [Exercícios práticos](#exercicios)\n\n## 1. Pré-requisitos e dicas\n\n- Ter o Python 3 instalado e noções básicas de variáveis e funções.\n- Use `print()` e experimente: modifique os exemplos!\n- Documentação oficial: https://docs.python.org/3/tutorial/\n\n## 2. Tipos básicos (contexto rápido)\n\nPython tem vários tipos embutidos. Alguns úteis como contexto para as estruturas de dados:\n\n- `int`, `float`, `bool`\n- `str` (strings são **imutáveis**)\n- `None` (ausência de valor)\n- `bytes`, `bytearray` (úteis para dados binários)\n\n> As estruturas de dados que veremos a seguir **armazenam** esses valores.\n\n\n## 3. Listas (`list`)\n\n- **Mutáveis**\n- Ordenadas (mantêm a ordem de inserção)\n- Permitem elementos repetidos\n- Acessadas por índice (começa em 0)\n\n::: {#939c3ee7 .cell execution_count=1}\n``` {.python .cell-code}\n# Criação e acesso\nnums = [10, 20, 30, 40]\nprint(\"lista:\", nums)\nprint(\"primeiro elemento:\", nums[0])\nprint(\"último elemento:\", nums[-1])\n\n# Slicing (fatiamento)\nprint(\"slice 1..3:\", nums[1:3])\nprint(\"cópia rasa via slice:\", nums[:])  # nova lista com os mesmos itens\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nlista: [10, 20, 30, 40]\nprimeiro elemento: 10\núltimo elemento: 40\nslice 1..3: [20, 30]\ncópia rasa via slice: [10, 20, 30, 40]\n```\n:::\n:::\n\n\n::: {#b5c5ea60 .cell execution_count=2}\n``` {.python .cell-code}\n# Métodos comuns\nnums = [3, 1, 4]\nnums.append(1)        # adiciona no fim\nnums.extend([5, 9])   # estende com iterável\nnums.insert(1, 2)     # insere na posição 1\nprint(nums)\n\nnums.remove(1)        # remove primeira ocorrência de 1\nprint(nums)\n\npopped = nums.pop()   # remove e retorna o último\nprint(\"popped:\", popped, \"| lista:\", nums)\n\nnums.reverse()        # in-place\nprint(\"reversa:\", nums)\n\n# sort in-place vs sorted (cópia ordenada)\nnums.sort()\nprint(\"sort:\", nums)\nprint(\"sorted (cópia):\", sorted([3,1,4,1,5]))\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[3, 2, 1, 4, 1, 5, 9]\n[3, 2, 4, 1, 5, 9]\npopped: 9 | lista: [3, 2, 4, 1, 5]\nreversa: [5, 1, 4, 2, 3]\nsort: [1, 2, 3, 4, 5]\nsorted (cópia): [1, 1, 3, 4, 5]\n```\n:::\n:::\n\n\n::: {#a3fce0ef .cell execution_count=3}\n``` {.python .cell-code}\n# Comportamento de mutabilidade\na = [1, 2, 3]\nb = a           # b referencia a MESMA lista\nb.append(4)\nprint(\"a:\", a, \"| b:\", b)  # ambos mudam\n\n# Se quiser uma cópia rasa:\nc = a.copy()\nc.append(5)\nprint(\"a (após copy):\", a, \"| c:\", c)\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na: [1, 2, 3, 4] | b: [1, 2, 3, 4]\na (após copy): [1, 2, 3, 4] | c: [1, 2, 3, 4, 5]\n```\n:::\n:::\n\n\n::: {#c02d7d9c .cell execution_count=4}\n``` {.python .cell-code}\n# Listas aninhadas e armadilhas de cópia rasa\nimport copy\n\nm1 = [[1,2],[3,4]]\nm2 = m1.copy()           # cópia rasa: sublistas são compartilhadas\nm2[0].append(99)\nprint(\"m1:\", m1, \"| m2:\", m2)  # ambas afetadas\n\nm3 = copy.deepcopy(m1)   # cópia profunda: estrutura completa duplicada\nm3[1].append(77)\nprint(\"m1:\", m1, \"| m3:\", m3)\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nm1: [[1, 2, 99], [3, 4]] | m2: [[1, 2, 99], [3, 4]]\nm1: [[1, 2, 99], [3, 4]] | m3: [[1, 2, 99], [3, 4, 77]]\n```\n:::\n:::\n\n\n## 4. Tuplas (`tuple`)\n\n- **Imutáveis**\n- Ordenadas\n- Úteis para **agrupamento** de dados e como chaves de dicionários (quando composto por itens imutáveis)\n\nDica: desembrulhar (unpacking) é muito prático com tuplas.\n\n::: {#95c2393d .cell execution_count=5}\n``` {.python .cell-code}\n# Criação e unpacking\nponto = (3, 4)\nx, y = ponto\nprint(f\"x={x}, y={y}\")\n\n# Tupla de 1 elemento precisa de vírgula final\num = (42,)\nprint(type(um), um)\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx=3, y=4\n<class 'tuple'> (42,)\n```\n:::\n:::\n\n\n## 5. Conjuntos (`set`, `frozenset`)\n\n- **Não ordenados** (sem índices)\n- **Únicos** (eliminam duplicatas)\n- Operações de teoria de conjuntos: união, interseção, diferença\n\n`frozenset` é a versão **imutável** de `set`.\n\n::: {#6a7e9066 .cell execution_count=6}\n``` {.python .cell-code}\nA = {1, 2, 3, 3}\nB = set([3, 4, 5])\n\nprint(\"A (sem duplicatas):\", A)\nprint(\"B:\", B)\nprint(\"união:\", A | B)\nprint(\"interseção:\", A & B)\nprint(\"diferença A-B:\", A - B)\nprint(\"diferença simétrica:\", A ^ B)\n\n# frozenset\nF = frozenset([1,2,2,3])\nprint(\"frozenset:\", F)\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA (sem duplicatas): {1, 2, 3}\nB: {3, 4, 5}\nunião: {1, 2, 3, 4, 5}\ninterseção: {3}\ndiferença A-B: {1, 2}\ndiferença simétrica: {1, 2, 4, 5}\nfrozenset: frozenset({1, 2, 3})\n```\n:::\n:::\n\n\n## 6. Dicionários (`dict`)\n\n- **Mutáveis**\n- Mapeiam **chaves** para **valores**\n- Desde o Python 3.7 preservam a ordem de inserção\n\nChaves precisam ser **hashable** (imutáveis, como `str`, `int`, `tuple` de imutáveis, `frozenset`).\n\n::: {#c6014862 .cell execution_count=7}\n``` {.python .cell-code}\n# Criação e acesso\nprecos = {\"banana\": 5.0, \"maçã\": 4.5}\nprint(\"preços:\", precos)\nprint(\"preço da maçã:\", precos[\"maçã\"])\n\n# get com default (evita KeyError)\nprint(\"preço da pera (default -1):\", precos.get(\"pera\", -1))\n\n# Inserção/atualização\nprecos[\"laranja\"] = 6.0\nprecos.update({\"banana\": 5.5})\nprint(precos)\n\n# Remoção\nval = precos.pop(\"laranja\")\nprint(\"removido:\", val, \"| atual:\", precos)\n\n# Iteração\nfor fruta, valor in precos.items():\n    print(fruta, \"->\", valor)\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npreços: {'banana': 5.0, 'maçã': 4.5}\npreço da maçã: 4.5\npreço da pera (default -1): -1\n{'banana': 5.5, 'maçã': 4.5, 'laranja': 6.0}\nremovido: 6.0 | atual: {'banana': 5.5, 'maçã': 4.5}\nbanana -> 5.5\nmaçã -> 4.5\n```\n:::\n:::\n\n\n::: {#fec4ee5b .cell execution_count=8}\n``` {.python .cell-code}\n# Métodos úteis\nd = {\"a\": 1, \"b\": 2}\nprint(\"keys:\", list(d.keys()))\nprint(\"values:\", list(d.values()))\nprint(\"items:\", list(d.items()))\n\n# setdefault: retorna valor existente ou define default\ncontagens = {}\nfor ch in \"banana\":\n    contagens.setdefault(ch, 0)\n    contagens[ch] += 1\nprint(\"contagens:\", contagens)\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nkeys: ['a', 'b']\nvalues: [1, 2]\nitems: [('a', 1), ('b', 2)]\ncontagens: {'b': 1, 'a': 3, 'n': 2}\n```\n:::\n:::\n\n\n## 7. Compreensões (list/set/dict)\n\nForma concisa e pythonista de construir coleções.\n\n::: {#e79455c3 .cell execution_count=9}\n``` {.python .cell-code}\n# List comprehension\nquadrados = [x*x for x in range(6)]\nprint(\"quadrados:\", quadrados)\n\n# Com condição (if)\npares = [x for x in range(10) if x % 2 == 0]\nprint(\"pares:\", pares)\n\n# Dict comprehension\nd = {x: x*x for x in range(5)}\nprint(\"dict:\", d)\n\n# Set comprehension\ns = {ch for ch in \"abracadabra\" if ch not in \"bc\"}\nprint(\"set:\", s)\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nquadrados: [0, 1, 4, 9, 16, 25]\npares: [0, 2, 4, 6, 8]\ndict: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}\nset: {'d', 'a', 'r'}\n```\n:::\n:::\n\n\n## 8. Cópias: shallow vs deep\n\n- **Cópia rasa** (shallow): duplica apenas o contêiner, **compartilha** referências internas.\n  - Exemplos: `list.copy()`, `dict.copy()`, `set.copy()`, slicing (`seq[:]`), `copy.copy(obj)`\n- **Cópia profunda** (deep): duplica recursivamente toda a estrutura.\n  - Exemplo: `copy.deepcopy(obj)`\n\n::: {#76953b9c .cell execution_count=10}\n``` {.python .cell-code}\nimport copy\n\noriginal = {\"nums\": [1,2,3], \"ok\": True}\nshallow = original.copy()\ndeep = copy.deepcopy(original)\n\nshallow[\"nums\"].append(99)\ndeep[\"nums\"].append(77)\n\nprint(\"original:\", original)\nprint(\"shallow :\", shallow)\nprint(\"deep    :\", deep)\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\noriginal: {'nums': [1, 2, 3, 99], 'ok': True}\nshallow : {'nums': [1, 2, 3, 99], 'ok': True}\ndeep    : {'nums': [1, 2, 3, 77], 'ok': True}\n```\n:::\n:::\n\n\n## 9. Pilhas e Filas\n\n- **Pilha (stack)**: LIFO. Use `list` com `append()` / `pop()`.\n- **Fila (queue)**: FIFO. Prefira `collections.deque` (eficiente em ambos os lados).\n\n::: {#e4d9f824 .cell execution_count=11}\n``` {.python .cell-code}\n# Pilha com list\nstack = []\nstack.append(\"a\")\nstack.append(\"b\")\nprint(\"pop:\", stack.pop())  # remove \"b\"\nprint(\"resto:\", stack)\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npop: b\nresto: ['a']\n```\n:::\n:::\n\n\n::: {#97370aec .cell execution_count=12}\n``` {.python .cell-code}\n# Fila com deque\nfrom collections import deque\n\nfila = deque()\nfila.append(\"primeiro\")\nfila.append(\"segundo\")\nprint(\"popleft:\", fila.popleft())  # remove \"primeiro\"\nprint(\"resto:\", fila)\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npopleft: primeiro\nresto: deque(['segundo'])\n```\n:::\n:::\n\n\n## 10. Exercícios práticos\n\nExecute as células e complete onde indicado. Há *asserts* para conferir automaticamente.\n\n::: {#f0404703 .cell execution_count=13}\n``` {.python .cell-code}\n# 10.1) Remova duplicatas preservando a ordem usando set de apoio\ndef remove_duplicatas(seq):\n    vistos = set()\n    res = []\n    for x in seq:\n        if x not in vistos:\n            vistos.add(x)\n            res.append(x)\n    return res\n\nassert remove_duplicatas([1,2,1,3,2,1,4]) == [1,2,3,4]\nprint(\"OK 10.1\")\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOK 10.1\n```\n:::\n:::\n\n\n::: {#e9dd04fb .cell execution_count=14}\n``` {.python .cell-code}\n# 10.2) Construa um dicionário de contagem de caracteres (case-insensitive) para uma string s\ndef contagem_chars(s):\n    s = s.lower()\n    cont = {}\n    for ch in s:\n        if ch.isalpha():\n            cont[ch] = cont.get(ch, 0) + 1\n    return cont\n\nassert contagem_chars(\"Banana!\") == {\"b\":1, \"a\":3, \"n\":2}\nprint(\"OK 10.2\")\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOK 10.2\n```\n:::\n:::\n\n\n::: {#be9c8280 .cell execution_count=15}\n``` {.python .cell-code}\n# 10.3) Use comprehension para obter os quadrados dos pares de 0..20\nquadrados_pares = [x*x for x in range(21) if x % 2 == 0]\nassert quadrados_pares[:5] == [0, 4, 16, 36, 64]\nprint(\"OK 10.3\")\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOK 10.3\n```\n:::\n:::\n\n\n::: {#f5d03bac .cell execution_count=16}\n``` {.python .cell-code}\n# 10.4) Extra: converter uma lista de pares (chave, valor) em dict e inverter (valor->chave)\npares = [(\"a\",1), (\"b\",2), (\"c\",3)]\nd = dict(pares)\ninvertido = {v:k for k,v in d.items()}\nassert d[\"b\"] == 2 and invertido[3] == \"c\"\nprint(\"OK 10.4 — gerado em 2025-08-09 22:49:32\")\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOK 10.4 — gerado em 2025-08-09 22:49:32\n```\n:::\n:::\n\n\n### Onde continuar?\n\n- Documentação oficial: *Built-in Types* e *Data Structures* no tutorial do Python.\n- `collections` (e.g., `Counter`, `defaultdict`, `namedtuple`), `heapq`, `array`, `bisect`.\n- Pratique escrevendo funções que **consomem** e **produzem** essas estruturas.\n\n",
    "supporting": [
      "python_estruturas_dados_tutorial_files"
    ],
    "filters": [],
    "includes": {}
  }
}